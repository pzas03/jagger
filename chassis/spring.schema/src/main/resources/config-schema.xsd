<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="xs3p.xsl"?>
<xsd:schema xmlns="http://www.griddynamics.com/schema/jagger"
            xmlns:beans="http://www.springframework.org/schema/beans"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            targetNamespace="http://www.griddynamics.com/schema/jagger"
            elementFormDefault="qualified">
    <xsd:import namespace="http://www.springframework.org/schema/beans"
                schemaLocation="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"/>

    <!--*************-->
    <!-- Basic types -->
    <!--*************-->

    <xsd:complexType name="identifiedType">
        <xsd:annotation><xsd:documentation>
            Basic type which contains id attribute to identify elements.
        </xsd:documentation></xsd:annotation>
        <xsd:attribute name="id" type="xsd:ID">
            <xsd:annotation><xsd:documentation>
                Id of the element
            </xsd:documentation></xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="identifiedRequiredType">
        <xsd:annotation><xsd:documentation>
            Basic type which contains id attribute to identify elements. id is required
        </xsd:documentation></xsd:annotation>
        <xsd:attribute name="id" type="xsd:ID" use="required">
            <xsd:annotation><xsd:documentation>
                Id of the element
            </xsd:documentation></xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="basicIdentifiedType" abstract="true">
        <xsd:annotation><xsd:documentation>
            Basic type with id.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedRequiredType">
                <xsd:attribute name="parent" type="xsd:string">
                    <xsd:annotation><xsd:documentation>
                        Parent of the element. All components of the parent will be inherited by this element
                    </xsd:documentation></xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="basicType" abstract="true">
        <xsd:annotation><xsd:documentation>
            Basic type which help you to realize inheritance.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:attribute name="parent" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="primitiveOrObjectAbstract" abstract="true" mixed="true">
        <xsd:annotation><xsd:documentation>
            A special type of object, which can configure with inner elements and with inner content.
        </xsd:documentation></xsd:annotation>
        <xsd:attribute name="parent" type="xsd:string"/>
        <xsd:attribute name="id" type="xsd:ID"/>
    </xsd:complexType>

    <xsd:complexType name="primitiveAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            A basic type for primitive objects.
        </xsd:documentation></xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="boolean">
        <xsd:simpleContent xml:base="xsd:boolean">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="integer">
        <xsd:simpleContent xml:base="xsd:integer">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="long">
        <xsd:simpleContent xml:base="xsd:long">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="float">
        <xsd:simpleContent xml:base="xsd:float">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="double">
        <xsd:simpleContent xml:base="xsd:double">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="string">
        <xsd:simpleContent xml:base="xsd:string">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="primitiveEntry">
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice>
                    <xsd:element name="value" type="primitiveAbstract"/>
                </xsd:choice>
                <xsd:attribute name="key" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="primitiveMap">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element name="param" type="primitiveEntry"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--***********************-->
    <!-- Configuration element -->
    <!--***********************-->

    <xsd:element name="configuration" type="configurationType">
        <xsd:annotation><xsd:documentation>
            Configuration is a main element in Jagger. It say Jagger what to do.
            Configuration can be configure by three elements - test-suite, latency-percentiles, report.
            Element test-suite describes what load you would like to execute.
            With element report you can configure how your report will look like.
            Latency-percentiles is an element, which
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="configurationType">
        <xsd:annotation><xsd:documentation>
            Configuration is a main element in Jagger. It say Jagger what to do.
            Configuration can configure by three elements - test-suite, latency-percentiles, report.
            Element test-suite describes what load you would like to execute.
            With element report you can configure how you report will look like.
            Latency-percentiles is an element, which
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:all>
                    <xsd:element name="test-suite" type="testSuiteTypeIn" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="session-execution-listeners" type="slistenersType" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="task-execution-listeners" type="tlistenersType" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="latency-percentiles" type="latencyPercentilesType" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="report" type="reportTypeIn" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="monitoring" type="monitoringType" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--*************************-->
    <!-- Configuration listeners -->
    <!--*************************-->

    <xsd:complexType name="slistenersType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="session-listener" type="listenerType"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="tlistenersType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="task-listener" type="listenerType"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listenerType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="latencyPercentilesType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice>
                    <xsd:element name="percentile" type="xsd:string" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--******************************-->
    <!-- Test-suite and test elements -->
    <!--******************************-->

    <xsd:element name="test-suite" type="testSuiteType">
        <xsd:annotation><xsd:documentation>
            Test-suite is a list of test-groups. Test-groups will runs in the order that you have.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="testSuiteType">
        <xsd:annotation><xsd:documentation>
            Test-suite is a list of test-groups. Test-groups will runs in the order that you have.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:sequence minOccurs="0" maxOccurs="unbounded">
                    <xsd:choice>
                        <xsd:element name="test-group" type="testGroupTypeIn" maxOccurs="unbounded"/>
                        <xsd:element name="listeners-test-suite" type="listenersTestSuiteType"/>
                    </xsd:choice>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="testSuiteTypeIn">
        <xsd:annotation><xsd:documentation>
            Test-suite is a list of test-groups. Test-groups will runs in the order that you have.
            You can set a reference to existing test-suite with attribute 'ref'.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="testSuiteType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="test-group" type="testGroupType">
        <xsd:annotation><xsd:documentation>
            Test-group is a list of tests. All tests will run in parallel mode.
            You can turn on monitoring, if you would like to see monitoring results for this test-group.
            Note : don't forget to set id for this element. Id will be written in report.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="testGroupType">
        <xsd:annotation><xsd:documentation>
            Test-group is a list of tests. All tests will run in parallel mode.
            You can turn on monitoring, if you would like to see monitoring results for this test-group.
            Decision maker is available for test-groups.
            Note : don't forget to set id for this element. Id will be written in report.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedRequiredType">
                <xsd:sequence minOccurs="0" maxOccurs="unbounded">
                    <xsd:choice>
                        <xsd:element name="test" type="testTypeIn" maxOccurs="unbounded"/>
                        <xsd:element name="listeners-test-group" type="listenersTestGroupType" maxOccurs="1"/>
                        <xsd:element name="listeners-test-group-decision-maker" type="listenersTestGroupDecisionMakerType" maxOccurs="1"/>
                    </xsd:choice>
                </xsd:sequence>
                <xsd:attribute name="monitoringEnabled" type="xsd:string" default="${chassis.conditions.monitoring.enable}" use="optional"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="testGroupTypeIn">
        <xsd:annotation><xsd:documentation>
            Test-group is a list of tests. All tests will run in parallel mode.
            You can turn on monitoring, if you would like to see monitoring results for this test-group.
            Note : don't forget to set id for this element. Id will be written in report.
            You can set a reference to existing test-group with attribute 'ref'.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="testGroupType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="test" type="testType">
        <xsd:annotation><xsd:documentation>
            Test have attribute testDescription and includes two child elements : load, termination.
            TestDescription describes what targets will be tested and what tool use to test it. Set id of test-description, which you would like to use.
            Element load say how often you would like to load targets.
            With element termination you can configure how long targets will be tested.
            Note : don't forget to set id for this element. Id will be written in report.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="testType">
        <xsd:annotation><xsd:documentation>
            Test have attribute testDescription and includes two child elements : load, termination.
            TestDescription describes what targets will be tested and what tool use to test it. Set id of test-description, which you would like to use.
            Element load say how often you would like to load targets.
            With element termination you can configure how long targets will be tested.
            Note : don't forget to set id for this element. Id will be written in report.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:all>
                    <xsd:element name="load" type="loadAbstract" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="termination" type="terminationAbstract" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="listeners-test" type="listenersTest" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
                <xsd:attribute name="startDelay" type="xsd:string" use="optional"/>
                <xsd:attribute name="testDescription" type="xsd:string" use="optional"/>
                <xsd:attribute name="parent" type="xsd:string" use="optional"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="testTypeIn">
        <xsd:complexContent>
            <xsd:extension base="testType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--********************************************-->
    <!-- Listeners for test-suite and test elements -->
    <!--********************************************-->

    <xsd:complexType name="listenersTestSuiteType">
        <xsd:annotation><xsd:documentation>
            A list of listener-test-suite elements, which give you an ability to execute some actions before and after test-suite.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element name="listener-test-suite" type="listenerTestSuiteAbstract" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listenerTestSuiteAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Abstract type for test-suite listeners
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listener-test-suite-ref">
        <xsd:annotation><xsd:documentation>
            A reference to listener-test-suite element or TestSuiteListener provider bean.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="listenerTestSuiteAbstract">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listenersTestGroupType">
        <xsd:annotation><xsd:documentation>
            A list of listener-test-group  elements, which give you an ability to execute some actions before and after test-group.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element name="listener-test-group" type="listenerTestGroupAbstract" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listenersTestGroupDecisionMakerType">
        <xsd:annotation><xsd:documentation>
            A list of listener-test-group-decision-maker elements, which give you an ability to execute some actions on decision making
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element name="listener-test-group-decision-maker" type="listenerTestGroupDecisionMakerAbstract" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listenerTestGroupAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Abstract type for test-group listeners
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listenerTestGroupDecisionMakerAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Abstract type for test-group-decision-maker listeners
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listener-test-group-decision-maker-ref">
        <xsd:annotation><xsd:documentation>
            A reference to listener-test-group-decision-maker element or TestGroupListenerDecisionMaker provider bean.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="listenerTestGroupDecisionMakerAbstract">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listener-test-group-ref">
        <xsd:annotation><xsd:documentation>
            A reference to listener-test-group element or TestGroupListener provider bean.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="listenerTestGroupAbstract">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listenersTest">
        <xsd:annotation><xsd:documentation>
            A list of t-listener elements, which give you an ability to execute some actions before and after test.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice>
                    <xsd:element name="listener-test" type="listenerTestAbstract" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listenerTestAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Test listener abstract type. See some realizations - listener-test-ref, listener-test-threads.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listener-test-ref">
        <xsd:annotation><xsd:documentation>
            A reference to test listener bean or element. Create bean, which implements TestListener, set bean id to ref attribute.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="listenerTestAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listener-test-threads">
        <xsd:annotation><xsd:documentation>
            Test listener, that collects number of Jagger threads.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="listenerTestAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--******************************-->
    <!-- Termination strategies types -->
    <!--******************************-->

    <xsd:complexType name="terminationAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Termination describes how long load will be executed.
            You can choose one of termination types - termination-duration, termination-iterations, termination-background.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="termination-iterations">
        <xsd:annotation><xsd:documentation>
            This termination strategy is helpful, when you would like to execute an exact number of iterations.
            Attribute 'iterations' say how much iterations you would like to execute.
            With attribute 'maxDuration' you can configure maximum execution time of test. By default it equals 2 hours.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="terminationAbstract">
                <xsd:attributeGroup ref="iterationsAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="termination-duration">
        <xsd:annotation><xsd:documentation>
            Use this termination, when you would like to execute your load within a certain time.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="terminationAbstract">
                <xsd:attributeGroup ref="durationAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="termination-background">
        <xsd:annotation><xsd:documentation>
            Test with such termination strategy will wait another tests in test-group to be stopped.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="terminationAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--************-->
    <!-- Load types -->
    <!--************-->

    <xsd:complexType name="loadAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Load is an element, which describes how often you would like to make load.
            You can choose one of load types - load-tps, load-user-groups, load-user-group, load-invocation.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:attribute name="tickInterval" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-user-groups">
        <xsd:annotation><xsd:documentation>
            This load is a list of elements user. Every such element imitates a group of threads.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:choice>
                    <xsd:element name="user" type="userGroupIn" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="userGroupIn">
        <xsd:annotation><xsd:documentation>
            This element imitates a group of threads. You can configure a number of threads by attributes.
            count is a max number of threads, that you can use.
            startCount is a start number of threads.
            startIn is a time duration between increase of threads.
            startBy is a number on how much to increase number of threads.
            life describes how long threads will be alive.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="userAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-user-group">
        <xsd:annotation><xsd:documentation>
            This load imitates one user group. See type load-user-groups.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="userAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-threads">
        <xsd:annotation><xsd:documentation>
            This type of load provides an exact count of threads, which will load your targets.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="virtualUserAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-invocation">
        <xsd:annotation><xsd:documentation>
                This type of load provides an exact number of invocations.
                Attribute exactcount says - how much invocations jagger have to execute, attribute threads - how much threads jagger can use. delay is a time(milliseconds) between invocations. By default it equals 0.
                Attribute period says - with what period jagger have to create load (exactcount samples with threads and determined delay), if not set then jagger creates load once.
                If ( ((exactcount/threads) * delay) + invocation time > period ) then jagger just wont be able to create such load in period. Actual period will be ~ (exactcount / threads) * delay + invocation time.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="invocationAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-tps">
        <xsd:annotation><xsd:documentation>
            This type of load imitates an exact number of transactions per second.
            By using attribute 'value', you can configure a number of transactions.
            Attribute 'maxThreadNumber' say how much threads you would like to use, to create such tps load. By default it equals 4000.
            Attribute 'warmUpTime' -  time for increase of tps.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="tpsAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-rps">
        <xsd:annotation><xsd:documentation>
            This type of load imitates an exact number of requests per second.
            By using attribute 'value', you can configure a number of requests.
            Attribute 'maxThreadNumber' say how much threads you would like to use, to create such rps load. By default it equals 4000.
            Attribute 'warmUpTime' -  time for increase of rps.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="tpsAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-ref">
        <xsd:annotation><xsd:documentation>
            Set bean of load, which you would like to use.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="userAttributes">
        <xsd:attribute name="count" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="startCount" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="startIn" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="startBy" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="life" type="xsd:string" use="required"></xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="virtualUserAttributes">
        <xsd:attribute name="count" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="delay" type="xsd:string" use="optional"></xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="invocationAttributes">
        <xsd:attribute name="exactcount" type="xsd:string" use="required">
            <xsd:annotation><xsd:documentation>
                Says - how much invocations jagger have to execute.
            </xsd:documentation></xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="threads" type="xsd:string" use="required">
            <xsd:annotation><xsd:documentation>
                Says how much threads jagger will use.
            </xsd:documentation></xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="delay" type="xsd:string" default="0">
            <xsd:annotation><xsd:documentation>
                Is a time(milliseconds) between invocations. By default it equals 0.
            </xsd:documentation></xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="period" type="xsd:string" use="optional">
            <xsd:annotation><xsd:documentation>
                Says with what period jagger have to create load (exactcount samples with threads and determined delay), if not set then jagger creates load once.
                If ( ((exactcount/threads) * delay) + invocation time > period ) then jagger just wont be able to create such load in period. Actual period will be ~ (exactcount / threads) * delay + invocation time.
            </xsd:documentation></xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="tpsAttributes">
        <xsd:attribute name="value" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="warmUpTime" type="xsd:string" use="optional"></xsd:attribute>
        <xsd:attribute name="maxThreadNumber" type="xsd:string"/>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="iterationsAttributes">
        <xsd:attribute name="maxDuration" type="xsd:string"></xsd:attribute>
        <xsd:attribute name="iterations" type="xsd:string" use="required"></xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="durationAttributes">
        <xsd:attribute name="duration" type="xsd:string" use="required"></xsd:attribute>
    </xsd:attributeGroup>

    <!--******************-->
    <!-- Test description -->
    <!--******************-->

    <xsd:element name="test-description" type="testDescriptionType">
        <xsd:annotation><xsd:documentation>
            Test description contains two elements - info-collectors and scenario.
            Info-collectors element is a list of collectors. Collector can be a metric element or a validator element.
            In scenario you can describe what targets will be loaded and what tool use to make load.
            You can turn on calibration by adding attribute calibration="true".
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="testDescriptionType">
        <xsd:annotation><xsd:documentation>
            Test description contains two elements - info-collectors and scenario.
            Info-collectors element is a list of collectors. Collector can be a metric element or a validator element.
            In scenario you can describe what targets will be loaded and what tool use to make load.
            You can turn on calibration by adding attribute calibration="true".
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicIdentifiedType">
                <xsd:all>
                    <xsd:element name="info-collectors" type="workloadListenersType" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="scenario" type="scenarioAbstract" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
                <xsd:attribute name="name" type="xsd:string">
                    <xsd:annotation><xsd:documentation>
                        Name of the test. Will be displayed in report and WebUI
                    </xsd:documentation></xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="version" type="xsd:string">
                    <xsd:annotation><xsd:documentation>
                        Version of the test. Just set to 1.
                    </xsd:documentation></xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="calibration" type="xsd:string" default="false">
                    <xsd:annotation><xsd:documentation>
                        Set 'true' if you want to provide calibration.
                        Calibration is a process, when Jagger in a simple (one thread) mode loads every target only one time.
                        Response from target is saved. During test run it can be used as benchmark to compare response
                        from system under test. Comparison will be provided if 'validator-consistency' is included in 'info-collectors'
                        Note that calibration can take long time when number of endpoints you are going to test is large!
                    </xsd:documentation></xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--***********************-->
    <!-- Invocation collectors -->
    <!--***********************-->

    <xsd:complexType name="workloadListenersType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="metric" type="metricAbstract" maxOccurs="unbounded"/>
                    <xsd:element name="validator" type="validatorAbstract" maxOccurs="unbounded"/>
                    <xsd:element name="listener-invocation" type="listenerInvocationAbstract" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="workloadCollectorAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:attribute name="displayName" type="xsd:string" use="optional">
                    <xsd:annotation><xsd:documentation>
                        Display name of metric.
                        If set - metric will appear in pdf/webUI with name equals to this attribute (plus aggregator.getName()).
                    </xsd:documentation></xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--**********************-->
    <!-- Invocation listeners -->
    <!--**********************-->

    <xsd:complexType name="listenerInvocationAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Abstract type for listener-invoke element. Listener help you to handle invocation actions(onStart, onSuccess, onFail).
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="workloadCollectorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listener-invocation-not-null-response">
        <xsd:annotation><xsd:documentation>
            A type of invocation listener, which count not null responses.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="listenerInvocationAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="listener-invocation-ref">
        <xsd:annotation><xsd:documentation>
            A reference to custom listener. Create Provider bean, which provides objects of InvocationListener type.
            Now you can set id of this bean as attribute 'ref'.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="listenerInvocationAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--************************-->
    <!-- Metric collectors types-->
    <!--************************-->

    <xsd:complexType name="metricAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Metric is a kind of collector, which calculate some information from responses. The result is a sum of all calculations.
            Possible types of metric : metric-success-rate, metric-not-null-response, metric-custom, metric-ref.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="workloadCollectorAbstract">
                <xsd:choice>
                    <xsd:element name="metric-aggregator" type="metricAggregatorAbstract" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:choice>
                <xsd:attribute name="plotData" type="xsd:string" default="false">
                    <xsd:annotation><xsd:documentation>
                        When set to 'true' detailed data 'metric vs time' will be saved to DB and displayed in report and WebUI plots
                    </xsd:documentation></xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="saveSummary" type="xsd:string" default="true">
                    <xsd:annotation><xsd:documentation>
                        When set to 'true' metric summary will be saved to DB and displayed in report and WebUI summary page.
                        Summary is calculated with use of aggregator. It can be mean, sigma, max, min values or some values calculated by custom aggregator
                    </xsd:documentation></xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-success-rate">
        <xsd:annotation><xsd:documentation>
            This metric calculates success rate and number of fails
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-not-null-response">
        <xsd:annotation><xsd:documentation>
            This metric indexes number of not null responses.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-custom">
        <xsd:annotation><xsd:documentation>
            You can create your custom metric. Create bean with your own class, which implements interface MetricCalculator.
            Now you can set id of this bean as attribute 'calculator'.
            See docu section about custom metrics to learn more.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAbstract">
                <xsd:attribute name="calculator" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-ref">
        <xsd:annotation><xsd:documentation>
            You can create your custom collector. Create bean with your own class, which implements interface MetricCollectorProvider.
            Now you can set id of this bean as attribute 'ref'.
            See docu section about custom collectors to learn more.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--******************-->
    <!-- Aggregator types -->
    <!--******************-->

    <xsd:complexType name="metricAggregatorAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Metric aggregator is a aggregation function for metric.
        </xsd:documentation></xsd:annotation>
    </xsd:complexType>

    <xsd:complexType name="metric-aggregator-ref">
        <xsd:annotation><xsd:documentation>
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAggregatorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-aggregator-avg">
        <xsd:annotation><xsd:documentation>
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAggregatorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-aggregator-sum">
        <xsd:annotation><xsd:documentation>
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAggregatorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-aggregator-std">
        <xsd:annotation><xsd:documentation>
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAggregatorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--******************-->
    <!-- Validators types -->
    <!--******************-->

    <xsd:complexType name="validatorAbstract">
        <xsd:annotation><xsd:documentation>
            Validator is a kind of collector, which validate responses. The result is a percent number of valid responses.
            Choose one of validator types - validator-not-null-response, validator-consistency, validator-custom, validator-ref.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="workloadCollectorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="validator-consistency">
        <xsd:annotation><xsd:documentation>
            Need to add info
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="validatorAbstract">
                <xsd:attribute name="queryEq" type="xsd:string"/>
                <xsd:attribute name="endpointEq" type="xsd:string"/>
                <xsd:attribute name="resultEq" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="validator-not-null-response">
        <xsd:annotation><xsd:documentation>
            This validator validates that response doesn't equals null.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="validatorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="validator-ref">
        <xsd:annotation><xsd:documentation>
            Set validator element, that you would like to use.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="validatorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="validator-custom">
        <xsd:annotation><xsd:documentation>
            If you would like to use you custom validator - create your own class, which extends class ResponseValidator.
            Now set attribute 'validator' full name of your class.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="validatorAbstract">
                <xsd:attribute name="validator" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--***************-->
    <!-- Scenario types-->
    <!--***************-->

    <xsd:element name="scenario" type="scenarioAbstract">
        <xsd:annotation><xsd:documentation>
            Scenario describes what targets will be loaded and what tool use to make load.
            Possible type of scenarios : scenario-query-pool.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="scenarioAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Scenario describes what targets will be loaded and what tool use to make load.
            Possible type of scenarios : scenario-query-pool.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="scenario-query-pool" type="scenario-query-pool" substitutionGroup="scenario">
        <xsd:annotation><xsd:documentation>
            This scenario contains such elements - invoker, query-provider, endpoint-provider, query-distributor.
            Query-provider generate list of queries. Endpoint-provider generate list of endpoints.
            Query-distributor describes how to distribute queries by endpoints.
            Invoker invokes a query to load endpoint.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="scenario-query-pool">
        <xsd:annotation><xsd:documentation>
            This scenario contains such elements - invoker, query-provider, endpoint-provider, query-distributor.
            Query-provider generate list of queries. Endpoint-provider generate list of endpoints.
            Query-distributor describes how to distribute queries by endpoints.
            Invoker invoke a query to load endpoint.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="scenarioAbstract">
                <xsd:all>
                    <xsd:element name="invoker" type="invokerAbstract" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="query-provider" type="queryProviderAbstract" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="endpoint-provider" type="endpointProviderAbstract" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="query-distributor" type="queryDistributorAbstract" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
                <xsd:attribute name="calibrationSamplesCount" type="xsd:int" use="optional"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="scenario-ref">
        <xsd:annotation><xsd:documentation>
            Set scenario element, that you would like to use.
            If you would like to create you own scenario, set id of bean, which class implements interface ScenarioFactory.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="scenarioAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--<xsd:element name="scenario-http" type="scenario-http" substitutionGroup="scenario"/>-->
    <!--<xsd:complexType name="scenario-http">-->
    <!--<xsd:complexContent>-->
    <!--<xsd:extension base="scenarioAbstract">-->
    <!--<xsd:all>-->
    <!--<xsd:element name="endpoint" type="xsd:string" minOccurs="1" maxOccurs="1"/>-->
    <!--<xsd:element name="http-query" type="query-http" minOccurs="1" maxOccurs="1"/>-->
    <!--</xsd:all>-->
    <!--</xsd:extension>-->
    <!--</xsd:complexContent>-->
    <!--</xsd:complexType>-->



    <!--****************-->
    <!-- Invokers types -->
    <!--****************-->

    <xsd:complexType name="invokerAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Invoker invokes a query to load endpoint.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="invoker-apache-http">
        <xsd:annotation><xsd:documentation>
            An invoker, that invoke apache http query (based on 'org.apache.http.client.methods.HttpRequestBase').
            org.apache.http.client.methods. HttpGet, HttpPos, HttpPut ...
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="invokerAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="invoker-http">
        <xsd:annotation><xsd:documentation>
            An invoker, that creates HTTP query.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="invokerAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="invoker-soap">
        <xsd:annotation><xsd:documentation>
            An invoker, that creates SOAP query.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="invokerAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="invoker-class">
        <xsd:annotation><xsd:documentation>
            Set class name of invoker, that you would like to use.
            Note - add an object of this class in context - create bean with this class.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="invokerAbstract">
                <xsd:attribute name="class" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--*****************-->
    <!-- Query providers -->
    <!--*****************-->

    <xsd:element name="query-provider" type="queryProviderAbstract">
        <xsd:annotation><xsd:documentation>
            Query provider is a source, where jagger can take queries.
            Possible types of query-provider : query-provider-list, query-provider-ref.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="queryProviderAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Query provider is a source, where jagger can take queries.
            Possible types of query-provider : query-provider-list, query-provider-ref.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="query-provider-list" type="query-provider-list" substitutionGroup="query-provider">
        <xsd:annotation><xsd:documentation>
            This element is a list of elements - query.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="query-provider-list">
        <xsd:annotation><xsd:documentation>
            This element is a list of elements - query.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryProviderAbstract">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element ref="query"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="query-provider-file" type="query-provider-file" substitutionGroup="query-provider">
        <xsd:annotation><xsd:documentation>
            This element is a file of line-separated elements - query.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="query-provider-file">
        <xsd:annotation><xsd:documentation>
            This element is a file of line-separated elements - query.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryProviderAbstract">
                <xsd:choice minOccurs="0" maxOccurs="1">
                    <xsd:element name="object-creator" type="objectCreatorAbstract"/>
                </xsd:choice>
                <xsd:attribute name="delimeter" type="xsd:string" use="optional"/>
                <xsd:attribute name="path" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="query-provider-csv" type="query-provider-csv" substitutionGroup="query-provider">
        <xsd:annotation><xsd:documentation>
            This element is a file of csv elements - query.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="query-provider-csv">
        <xsd:annotation><xsd:documentation>
            This element is a file of csv elements - query.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryProviderAbstract">
                <xsd:choice minOccurs="1" maxOccurs="1">
                    <xsd:element name="objectCreator" type="objectCreatorAbstract"/>
                </xsd:choice>
                <xsd:attribute name="path" type="xsd:string" use="required"/>
                <xsd:attribute name="readHeader" type="xsd:string" use="optional" default="true"/>
                <xsd:attribute name="strategy" type="csvStrategy" use="optional" default="DEFAULT"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-provider-ref">
        <xsd:annotation><xsd:documentation>
            Set reference to your query-provider bean. This bean must implements interface Iterable.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryProviderAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="query" type="queryType">
        <xsd:annotation><xsd:documentation>
            Possible type of query : query-http, query-ref.
            If you don't choose any of type, query will be represented as a string.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="queryType" mixed="true">
        <xsd:annotation><xsd:documentation>
            Possible type of query : query-http, query-ref.
            If you don't choose any of type, query will be represented as a string.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="primitiveOrObjectAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="query-http" type="query-http" substitutionGroup="query">
        <xsd:annotation><xsd:documentation>
            This query implements http query. You can configure it with elements - method-params and client-params.
            Set attribute 'method', it describes what http method you would like to use(for example - GET).
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="query-http" mixed="true">
        <xsd:annotation><xsd:documentation>
            This query implements http query. You can configure it with elements - method-params and client-params.
            Set attribute 'method', it describes what http method you would like to use(for example - GET).
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryType">
                <xsd:sequence>
                    <xsd:element name="method-params" type="primitiveMap" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="client-params" type="primitiveMap" minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
                <xsd:attribute name="method" type="httpMethodsEnum" default="GET"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="httpMethodsEnum">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="GET"/>
            <xsd:enumeration value="POST"/>
            <xsd:enumeration value="PUT"/>
            <xsd:enumeration value="DELETE"/>
            <xsd:enumeration value="TRACE"/>
            <xsd:enumeration value="HEAD"/>
            <xsd:enumeration value="OPTIONS"/>
            <xsd:enumeration value="CONNECT"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="query-ref" mixed="true">
        <xsd:annotation><xsd:documentation>
            Set reference to query bean.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryType">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--********************-->
    <!-- Endpoint providers -->
    <!--********************-->

    <xsd:complexType name="endpointProviderAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Endpoint provider is a source, where jagger can take endpoints.
            Possible types of endpoint-provider : endpoint-provider-list, endpoint-provider-ref.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="endpoint-provider-list" type="endpoint-provider-list">
        <xsd:annotation><xsd:documentation>
            This element is a list of elements - endpoint.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="endpoint-provider-list">
        <xsd:annotation><xsd:documentation>
            This element is a list of elements - endpoint.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointProviderAbstract">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element name="endpoint" type="endpointType"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="endpoint-provider-file" type="endpoint-provider-file">
        <xsd:annotation><xsd:documentation>
            This element is a file of line-separated elements - endpoint.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="endpoint-provider-file">
        <xsd:annotation><xsd:documentation>
            This element is a file of line-separated elements - endpoint.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointProviderAbstract">
                <xsd:choice minOccurs="0" maxOccurs="1">
                    <xsd:element name="object-creator" type="objectCreatorAbstract"/>
                </xsd:choice>
                <xsd:attribute name="delimeter" type="xsd:string" use="optional"/>
                <xsd:attribute name="path" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="endpoint-provider-csv" type="endpoint-provider-csv">
        <xsd:annotation><xsd:documentation>
            This element is a file of csv elements - endpoint.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="endpoint-provider-csv">
        <xsd:annotation><xsd:documentation>
            This element is a file of csv elements - query.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointProviderAbstract">
                <xsd:choice minOccurs="1" maxOccurs="1">
                    <xsd:element name="object-creator" type="objectCreatorAbstract"/>
                </xsd:choice>
                <xsd:attribute name="path" type="xsd:string" use="required"/>
                <xsd:attribute name="readHeader" type="xsd:string" use="optional" default="true"/>
                <xsd:attribute name="strategy" type="csvStrategy" use="optional" default="DEFAULT"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpoint-provider-ref">
        <xsd:annotation><xsd:documentation>
            Set reference to endpoint-provider element or bean. This bean must implements interface Iterable.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointProviderAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpointType" mixed="true">
        <xsd:annotation><xsd:documentation>
            Possible type of endpoint : endpoint-ref.
            If you don't choose any of type, endpoint will be represented as a string.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="primitiveOrObjectAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpoint-ref" mixed="true">
        <xsd:annotation><xsd:documentation>
            Set reference to endpoint bean.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointType">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--************************************-->
    <!-- CSV strategies and object creators -->
    <!--************************************-->

    <xsd:simpleType name="csvStrategy">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="DEFAULT"/>
            <xsd:enumeration value="EXCEL"/>
            <xsd:enumeration value="TDF"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="objectCreatorAbstract" abstract="true" >
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="object-creator-ref">
        <xsd:complexContent>
            <xsd:extension base="objectCreatorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--********************-->
    <!-- Query distributors -->
    <!--********************-->

    <xsd:complexType name="queryDistributorAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Query distributor is an object, that provides an algorithm how to distribute queries by endpoints.
            Possible types of query-distributor : query-distributor-round-robin, query-distributor-one-by-one, query-distributor-ref.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="queryDistributorRandomAbstract" abstract="true">
        <xsd:annotation><xsd:documentation>
            Extension of queryDistributorAbstract complexType.
            "randomSeed" attribute added. Should be positive long type.
            This attribute will not influence on work of distributor, but execution order of pairs
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryDistributorAbstract">
                <xsd:attribute name="randomSeed" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            When this attribute set , each thread will randomly choose pair in pair collection with help of
                            Random class object with seed calculated from specified randomSeed:
                            for every new thread:
                            1. seed = randomSeed;
                            2. randomSeed ++;

                            Pair is (endpoint, query).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-distributor-round-robin">
        <xsd:annotation><xsd:documentation>
            Encapsulates round robin algorithm.
            For input: endpoints [e1, e2] and queries [q1, q2, q3] returns (invoker, query) pairs in following order: (e1, q1), (e2, q2), (e1, q3), (e2, q1), (e1, q2), (e2, q3).
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryDistributorRandomAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-distributor-one-by-one">
        <xsd:annotation><xsd:documentation>
            Schedules queries across endpoints one by one.
            For input: endpoints [e1, e2] and queries [q1, q2, q3] executes actions in following order: (e1, q1), (e2, q1), (e1, q2), (e2, q2), (e1, q3), (e2, q3).
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryDistributorRandomAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-distributor-ref">
        <xsd:annotation><xsd:documentation>
            Set reference to query-distributor bean. Class of this bean must inheritance class QueryPoolLoadBalancer.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryDistributorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--***********-->
    <!-- Reporting -->
    <!--***********-->

    <xsd:element name="report" type="reportType">
        <xsd:annotation><xsd:documentation>
            This element can configure your report.
            outputReportLocation say where and how you would like to save your report.
            rootTemplateLocation is a name of jrxml file. Jrxml file is stylesheet file for your report.
            With element session-comparators you can configure session comparison.
        </xsd:documentation></xsd:annotation>
    </xsd:element>

    <xsd:complexType name="reportType">
        <xsd:annotation><xsd:documentation>
            This element can configure your report.
            outputReportLocation say where and how you would like to save your report.
            rootTemplateLocation is a name of jrxml file. Jrxml file is stylesheet file for your report.
            With element session-comparators you can configure session comparison.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:all>
                    <xsd:element name="extensions" type="extensionsType" minOccurs="0"/>
                    <xsd:element name="session-comparators" type="sessionComparatorsType" minOccurs="0"/>
                </xsd:all>
                <xsd:attributeGroup ref="reportTypeAttribute"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="reportTypeIn">
        <xsd:complexContent>
            <xsd:extension base="reportType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="reportTypeAttribute">
        <xsd:attribute name="rootTemplateLocation" type="xsd:string"/>
        <xsd:attribute name="outputReportLocation" type="xsd:string"/>
    </xsd:attributeGroup>

    <xsd:complexType name="extensionsType">
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="extension" type="extensionType"></xsd:element>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="extensionType">
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="0" maxOccurs="1">
                    <xsd:element ref="beans:ref"/>
                </xsd:choice>
                <xsd:attributeGroup ref="extensionAttribute"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="extensionAttribute">
        <xsd:attribute name="ref" type="xsd:string" use="optional"/>
    </xsd:attributeGroup>

    <xsd:complexType name="sessionComparatorsType">
        <xsd:annotation><xsd:documentation>
            This element is a list of monitoring and workload comparators.
            By adding attribute 'baselineId' you can add a comparison between your current session and baseline session.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="comparator-monitoring" type="comparator-monitoring"/>
                    <xsd:element name="comparator-workload" type="comparator-workload"/>
                </xsd:choice>
                <xsd:attributeGroup ref="sessionComparatorsAttribute"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="comparatorAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="comparator-monitoring">
        <xsd:complexContent>
            <xsd:extension base="comparatorAbstract">
                <xsd:choice minOccurs="1" maxOccurs="1">
                    <xsd:element name="decision-maker" type="decisionMakerMonitoringAbstract"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="comparator-workload">
        <xsd:complexContent>
            <xsd:extension base="comparatorAbstract">
                <xsd:choice minOccurs="1" maxOccurs="1">
                    <xsd:element name="decision-maker" type="decisionMakerWorkloadAbstract"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="comparator-ref">
        <xsd:complexContent>
            <xsd:extension base="comparatorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decisionMakerAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="basicType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decisionMakerMonitoringAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerAbstract"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decisionMakerWorkloadAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerAbstract"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decision-maker-workload-throughput">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerWorkloadAbstract">
                <xsd:attribute name="fatalDeviationThreshold" type="xsd:string" use="required"/>
                <xsd:attribute name="warningDeviationThreshold" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decision-maker-monitoring-stddev">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerMonitoringAbstract">
                <xsd:attribute name="fatalDeviationThreshold" type="xsd:string" use="required"/>
                <xsd:attribute name="warningDeviationThreshold" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decision-maker-monitoring-ref">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerMonitoringAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decision-maker-workload-ref">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerWorkloadAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="sessionComparatorsAttribute">
        <xsd:attribute name="baselineId" type="xsd:string" use="optional" default="${chassis.engine.e1.reporting.session.comparison.baseline.session.id}"/>
        <xsd:attribute name="strategy" type="strategyType" use="optional"/>
    </xsd:attributeGroup>

    <xsd:simpleType name="strategyType">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="worstCase"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!--************-->
    <!-- Monitoring -->
    <!--************-->

    <xsd:complexType name="monitoringType">
        <xsd:annotation><xsd:documentation>
            This element can configure your monitoring.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:all>
                    <xsd:element name="monitoring-sut" type="monitoringSutType" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="monitoringSutType">
        <xsd:annotation><xsd:documentation>
            This element can configure monitoring on System Under Test.
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:all>
                    <xsd:element name="jmx-metrics" type="jmxMetricsType" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="jmxMetricsType">
        <xsd:annotation><xsd:documentation>
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice>
                    <xsd:element name="jmx-metrics-group" type="jmxMetricsGroupType" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:choice>
                <xsd:attributeGroup ref="jmxMetricsAttribute"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="jmxMetricsAttribute">
        <xsd:attribute name="ref" type="xsd:IDREF" use="optional"/>
    </xsd:attributeGroup>

    <xsd:complexType name="jmxMetricsGroupType">
        <xsd:annotation><xsd:documentation>
        </xsd:documentation></xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice>
                    <xsd:element name="jmx-metric-attribute" type="jmxMetricAttributeType" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:choice>
                <xsd:attributeGroup ref="jmxMetricsGroupAttribute"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="jmxMetricsGroupAttribute">
        <xsd:attribute name="groupName" type="xsd:string"/>
        <xsd:attribute name="objectName" type="xsd:string"/>
        <xsd:attribute name="ref" type="xsd:IDREF"/>
    </xsd:attributeGroup>

    <xsd:complexType name="jmxMetricAttributeType">
        <xsd:annotation>
            <xsd:documentation>
            </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

</xsd:schema>
